<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python Scrapy 爬虫框架介绍</title>
      <link href="/2022/12/09/python-Scrapy-%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/12/09/python-Scrapy-%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><pre><code>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。  其最初是为了 页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。</code></pre><h2 id="架构概览"><a href="#架构概览" class="headerlink" title="架构概览"></a>架构概览</h2><p>![[Pasted image 20221209100634.png]]</p><h3 id="各组件作用"><a href="#各组件作用" class="headerlink" title="各组件作用"></a>各组件作用</h3><h4 id="Scrapy-Engine"><a href="#Scrapy-Engine" class="headerlink" title="Scrapy Engine"></a>Scrapy Engine</h4><pre><code>引擎负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。 详细内容查看下面的数据流(Data Flow)部分。</code></pre><p>此组件相当于爬虫的“大脑”，是整个爬虫的调度中心。</p><h4 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器(Scheduler)"></a>调度器(Scheduler)</h4><pre><code>调度器从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎。</code></pre><p>初始的爬取URL和后续在页面中获取的待爬取的URL将放入调度器中，等待爬取。同时调度器会自动去除重复的URL（如果特定的URL不需要去重也可以通过设置实现，如post请求的URL）</p><h4 id="下载器-Downloader"><a href="#下载器-Downloader" class="headerlink" title="下载器(Downloader)"></a>下载器(Downloader)</h4><pre><code>下载器负责获取页面数据并提供给引擎，而后提供给spider。</code></pre><h4 id="Spiders"><a href="#Spiders" class="headerlink" title="Spiders"></a>Spiders</h4><pre><code>Spider是Scrapy用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。</code></pre><h4 id="Item-Pipeline"><a href="#Item-Pipeline" class="headerlink" title="Item Pipeline"></a>Item Pipeline</h4><pre><code>Item Pipeline负责处理被spider提取出来的item。典型的处理有清理、 验证及持久化(例如存取到数据库中)。</code></pre><p>当页面被爬虫解析所需的数据存入Item后，将被发送到项目管道(Pipeline)，并经过几个特定的次序处理数据，最后存入本地文件或存入数据库。</p><h4 id="下载器中间件-Downloader-middlewares"><a href="#下载器中间件-Downloader-middlewares" class="headerlink" title="下载器中间件(Downloader middlewares)"></a>下载器中间件(Downloader middlewares)</h4><pre><code>下载器中间件是在引擎及下载器之间的特定钩子(specific hook)，处理Downloader传递给引擎的response。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。</code></pre><p>通过设置下载器中间件可以实现爬虫自动更换user-agent、IP等功能。</p><h4 id="Spider中间件-Spider-middlewares"><a href="#Spider中间件-Spider-middlewares" class="headerlink" title="Spider中间件(Spider middlewares)"></a>Spider中间件(Spider middlewares)</h4><pre><code>Spider中间件是在引擎及Spider之间的特定钩子(specific hook)，处理spider的输入(response)和输出(items及requests)。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。</code></pre><h3 id="数据流-Data-flow"><a href="#数据流-Data-flow" class="headerlink" title="数据流(Data flow)"></a>数据流(Data flow)</h3><ol><li>引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该spider请求第一个要爬取的URL(s)。</li><li>引擎从Spider中获取到第一个要爬取的URL并在调度器(Scheduler)以Request调度。</li><li>引擎向调度器请求下一个要爬取的URL。</li><li>调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件(请求(request)方向)转发给下载器(Downloader)。</li><li>一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件(返回(response)方向)发送给引擎。</li><li>引擎从下载器中接收到Response并通过Spider中间件(输入方向)发送给Spider处理。</li><li>Spider处理Response并返回爬取到的Item及(跟进的)新的Request给引擎。</li><li>引擎将(Spider返回的)爬取到的Item给Item Pipeline，将(Spider返回的)Request给调度器。</li><li> (从第二步)重复直到调度器中没有更多地request，引擎关闭该网站。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python/Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 setup 语法糖的一些注意点</title>
      <link href="/2022/11/18/vue3-setup-%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2022/11/18/vue3-setup-%E8%AF%AD%E6%B3%95%E7%B3%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>这篇文章主要记录一些 setup 语法糖需要注意的地方，之后关于 setup 的小问题就不会新开文章了。</p><h2 id="1-vue-中-this-refs-在-setup-语法糖中的使用方法"><a href="#1-vue-中-this-refs-在-setup-语法糖中的使用方法" class="headerlink" title="1. vue 中 this.refs 在 setup 语法糖中的使用方法"></a>1. vue 中 this.refs 在 setup 语法糖中的使用方法</h2><h3 id="vue-："><a href="#vue-：" class="headerlink" title="vue ："></a>vue ：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt;</span><br></pre></td></tr></table></figure><p>在 js 代码中可以通过下面的方法访问 usernameInput:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">usernameInput</span></span><br></pre></td></tr></table></figure><p><strong>可以调用里面的方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 base-input 组件内有方法foo</span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">usernameInput</span>.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><h3 id="vue3使用"><a href="#vue3使用" class="headerlink" title="vue3使用:"></a>vue3使用:</h3><p>父组件调用子组件的时候设置ref值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildVue ref=&quot;childRef&quot; /&gt;</span><br></pre></td></tr></table></figure><p>设置完成后，vue3可以通过ref方法获取:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childRef = <span class="title function_">ref</span>();</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">childRef.<span class="property">value</span>.<span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br></pre></td></tr></table></figure><h2 id="2-vue2-和vue3的生命周期对比"><a href="#2-vue2-和vue3的生命周期对比" class="headerlink" title="2. vue2 和vue3的生命周期对比"></a>2. vue2 和vue3的生命周期对比</h2><h3 id="vue2-的生命周期："><a href="#vue2-的生命周期：" class="headerlink" title="vue2 的生命周期："></a>vue2 的生命周期：</h3><ol><li>创建数据代理、数据检测<br><a href="####beforeCreate()">beforeCrate()</a><br><a href="####Created()">created()</a></li><li>挂载<br><a href="####beforeMount()">beforeMount()</a><br><a href="####mounted()">mounted()</a></li><li>更新<br><a href="####beforeUpdate()">beforeUpdate()</a><br><a href="####updated()">updated()</a></li><li>销毁<br><a href="####beforeDestroy()">beforeDestroy()</a><br><a href="####destroyed()">destroyed()</a></li><li>activated 和 deactivated<br><a href="####activated()">activated()</a><br><a href="####deactivated()">deactivated()</a></li><li>errorCaptured<h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate()"></a>beforeCreate()</h4></li></ol><p><strong>在实例初始化之后</strong>,进行数据侦听和事件/侦听器的配置之前同步调用。<br>此时还没有进行数据代理，数据监测，<strong>所有vm身上并没有_data的属性</strong>。</p><h4 id="Create"><a href="#Create" class="headerlink" title="Create()"></a>Create()</h4><p>在<strong>实例创建完成后</strong>被立即同步调用。在这一步中，<strong>实例已完成对选项的处理</strong>，意味着以下内容已被配置完毕：<strong>数据侦听、计算属性、方法、事件/侦听器的回调函数。vm身上也存在_data属性</strong>。</p><h4 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount()"></a>beforeMount()</h4><p>在挂载开始之前被调用，这时页面中的插值语法都未被解析。**该钩子在服务器端渲染期间不被调用。</p><h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted()"></a>mounted()</h4><p>实例被挂载后调用，页面中的插值语法已经被解析了。该钩子在服务器端渲染期间不被调用。</p><p>注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 <code>mounted</code> 内部使用 <code>vm.$nextTick</code>。</p><h4 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate()"></a>beforeUpdate()</h4><p><strong>在数据发生改变后，DOM 被更新之前被调用。</strong> 该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</p><h4 id="updated"><a href="#updated" class="headerlink" title="updated()"></a>updated()</h4><p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</p><p>Updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick.</p><h4 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy()"></a>beforeDestroy()</h4><p><strong>实例销毁之前调用。在这一步，实例仍然完全可用。</strong></p><p>该钩子在服务器端渲染期间不被调用。</p><h4 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed()"></a>destroyed()</h4><p><strong>实例销毁后调用。</strong> 该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p><p>该钩子在服务器端渲染期间不被调用。</p><h4 id="activated（）"><a href="#activated（）" class="headerlink" title="activated（）"></a>activated（）</h4><p><strong>被 <code>keep-alive</code> 缓存的组件激活时调用</strong>。该钩子<strong>在服务器端渲染期间不被调用</strong>。</p><h4 id="deactivated（）"><a href="#deactivated（）" class="headerlink" title="deactivated（）"></a>deactivated（）</h4><p><strong>被 <code>keep-alive</code> 缓存的组件失活时调用。</strong> 该钩子在<strong>服务器端渲染期间不被调用</strong>。</p><h4 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h4><p>2.5.0+ 新增，在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p><h4 id="完整生命周期图"><a href="#完整生命周期图" class="headerlink" title="完整生命周期图"></a>完整生命周期图</h4><p>![[Pasted image 20221118161919.png]]</p><h3 id="vue3的生命周期"><a href="#vue3的生命周期" class="headerlink" title="vue3的生命周期:"></a>vue3的生命周期:</h3><p>在vue3的生命周期中没有了销毁之前（beforeDestroy ）以及销毁完毕（destroyed ）这两个生命周期。</p><p>取而代之的是卸载，卸载之前(beforeUnmount )以及卸载完毕（unmounted ）</p><p>Vue3中，生命周期有两种写法：</p><ol><li><p>配置项的形式</p></li><li><p>组合式api的形式</p></li></ol><h4 id="配置项的形式："><a href="#配置项的形式：" class="headerlink" title="配置项的形式："></a>配置项的形式：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//配置项的形式使用生命周期钩子</span><br><span class="line">        beforeCreate()&#123;</span><br><span class="line">            console.log(&#x27;beforeCreate&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line">            console.log(&#x27;created&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount()&#123;</span><br><span class="line">            console.log(&#x27;beforeMount&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            console.log(&#x27;mounted&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate()&#123;</span><br><span class="line">            console.log(&#x27;beforeUpdate&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        updated()&#123;</span><br><span class="line">            console.log(&#x27;updated&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUnmount()&#123;</span><br><span class="line">            console.log(&#x27;beforeUnmount&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounted()&#123;</span><br><span class="line">            console.log(&#x27;unmounted&#x27;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>组合式api的形式：<br>使用组合式api的形式，生命周期的名称发生了一些小变化，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate -&gt; 使用 setup()</span><br><span class="line">created -&gt; 使用 setup()</span><br><span class="line">beforeMount -&gt; onBeforeMount</span><br><span class="line">mounted -&gt; onMounted</span><br><span class="line">beforeUpdate -&gt; onBeforeUpdate</span><br><span class="line">updated -&gt; onUpdated</span><br><span class="line">beforeUnmount-&gt; onBeforeUnmount</span><br><span class="line">unmounted-&gt; onUnmounted</span><br></pre></td></tr></table></figure><p>在使用生命周期时，需要先引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted&#125; from  &#x27;vue&#x27;</span><br></pre></td></tr></table></figure><p>![[Pasted image 20221118162448.png]]</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>